---
alwaysApply: false
---

# Next.js Rule

针对 `Next.js` 16 项目的规则

## server action

如果你需要创建一个 `server action`，例如 `addUser`，你应该按照以下规则创建：

1. 在 `@/schemas` 目录下创建一个名为 `addUser.ts` 的文件，它的内容应该如下：

    ```typescript
    import { getParser } from "."
    import { z } from "zod"

    import { phoneSchema } from "./phone"

    import { roleSchema } from "./role"

    import { usernameSchema } from "./username"

    export const addUserSchema = z.object(
        {
            username: usernameSchema,
            phone: phoneSchema,
            role: roleSchema,
        },
        { message: "无效的用户参数" },
    )

    export type AddUserParams = z.infer<typeof addUserSchema>

    export const addUserParser = getParser(addUserSchema)
    ```

2. 在 `@/shared` 目录下创建一个名为 `addUser.ts` 的文件，它的内容应该如下：

    ```typescript
    import { prisma } from "@/prisma"
    import { User } from "@/prisma/generated/client"
    import { AddUserParams } from "@/schemas/addUser"
    import { ClientError } from "@/utils/clientError"

    export async function addUser({ username, phone }: AddUserParams) {
        const count = await prisma.user.count({ where: { username } })

        // 如果函数内部需要抛出错误，请使用 `ClientError` 类，它的使用方法与 `Error` 类一致，同时支持更多用法，详细请参考 `@/utils/clientError` 文件
        if (count > 0) throw new ClientError("用户名已存在")

        const count2 = await prisma.user.count({ where: { phone } })
        if (count2 > 0) throw new ClientError("手机号已存在")
        const user = await prisma.user.create({ data: { username, phone } })
        return user
    }

    // 如果这个 server action 只允许特定的用户指定，可以为 @/shared 目录下的响应函数添加一个 `filter` 属性
    // `filter` 属性接受两种类型，一种是 `boolean` 类型，一种是 `(user: User) => boolean` 函数类型
    // 当你传入 `boolean` 类型时， `true` 代表只有登录且未被禁用的用户才能访问，`false` 代表不做任何限制，包括未登录用户
    // 当你传入 `(user: User) => boolean` 函数类型时，函数返回 `true` 代表用户可以访问，返回 `false` 代表用户不能访问
    // filter 属性默认值为 `true`，代表只有登录且未被禁用的用户才能访问
    addUser.filter = function filter(user: User) {
        return user.role === "ADMIN"
    }
    ```

3. 在 `@/actions` 目录下创建一个名为 `addUser.ts` 的文件，它的内容应该如下：

    ```typescript
    "use server"

    import { addUserSchema } from "@/schemas/addUser"
    import { addUser } from "@/shared/addUser"
    import { createResponseFn } from "@/utils/createResponseFn"

    export const addUserAction = createResponseFn({
        fn: addUser,
        schema: addUserSchema,
        name: "addUser",
    })
    ```

4. 在 `@/hooks` 目录下创建一个名为 `useAddUser.ts` 的文件，创建它的规则与 `api.mdc` 中创建 `hook` 的规则一致，唯一不同的地方是，你需要先使用 `createRequestFn` 创建 `queryFn` 或者 `mutationFn` 函数，命名为 `addUserClient` 并且导出，例如：

    ```typescript
    import { useMutation, UseMutationOptions } from "@tanstack/react-query"
    import { createRequestFn } from "deepsea-tools"
    import { addUserAction } from "@/actions/addUser"
    import { User } from "@/prisma/generated/client"
    import { AddUserParams } from "@/schemas/addUser"

    export const addUserClient = createRequestFn(addUserAction)

    export interface UseAddUserParams<TContext = never> extends Omit<UseMutationOptions<User, Error, AddUserParams, TContext>, "mutationFn"> {}

    export function useAddUser<TContext = never>(params: UseAddUserParams<TContext> = {}) {
        return useMutation<User, Error, AddUserParams, TContext>({
            mutationFn: addUserClient,
            ...params,
        })
    }
    ```

## Schema

当你需要创建一个 `schema` 时，如果是一个对象或者数组，你应该将它们独立出来作为一个文件，而不是直接在 `schema` 中定义，例如：

```typescript
import { getParser } from "."
import { z } from "zod"

export const addUserSchema = z.object(
    {
        username: z
            .string({ message: "无效的用户名" })
            .min(4, { message: "用户名长度不能低于 4 位" })
            .max(16, { message: "用户名长度不能超过 16 位" })
            .regex(/^[a-zA-Z0-9_]+$/, { message: "用户名只能包含字母、数字和下划线" })
            .regex(/^[a-zA-Z]/, { message: "用户名必须以字母开头" }),
        phone: z.string({ message: "无效的手机号" }).regex(phoneRegex, { message: "无效的手机号" }),
    },
    { message: "无效的用户参数" },
)

export type AddUserParams = z.infer<typeof addUserSchema>

export const addUserParser = getParser(addUserSchema)
```

你应该将 `usernameSchema` 和 `phoneSchema` 独立出来成为两个独立的文件，便于服用，而不是直接在 `schema` 中定义，例如：

```typescript
import { getParser } from "."
import { z } from "zod"

export const usernameSchema = z
    .string({ message: "无效的用户名" })
    .min(4, { message: "用户名长度不能低于 4 位" })
    .max(16, { message: "用户名长度不能超过 16 位" })
    .regex(/^[a-zA-Z0-9_]+$/, { message: "用户名只能包含字母、数字和下划线" })
    .regex(/^[a-zA-Z]/, { message: "用户名必须以字母开头" })

export type UsernameParams = z.infer<typeof usernameSchema>

export const usernameParser = getParser(usernameSchema)
```

## Utils

`@/utils` 目录下的文件必须只能是客户端可以访问的工具函数，或者客户端和服务器都可以访问的工具函数，如果一个工具函数只能在服务器访问，或者不能暴露给客户端，请将它放在 `@/server` 目录下

## Middleware

在 `Next.js` 16 中，`middleware.ts` 已经被弃用，请使用 `proxy.ts` 文件来实现中间件功能，并且导出的函数名必须为 `proxy`，例如：

```typescript
import { NextRequest, NextResponse } from "next/server"

export async function proxy(request: NextRequest) {
    const requestHeaders = new Headers(request.headers)
    requestHeaders.set("current-url", request.url)

    const response = NextResponse.next({
        request: {
            headers: requestHeaders,
        },
    })

    return response
}
```
